functions urt_lock
# URT - Unified Real-Time Interface
version version 0.1.0
author Shahbaz Youssefi
keyword real-time
keyword middleware
keyword interface
shortcut index
shortcut globals
shortcut constants
previous functions urt_mem
next functions urt_error

Functions of this module handle private and shared sync lock allocation, free and access. The actual types depend on the real-time
back-end.

TYPE urt_sem: opaque
	A type representing a semaphore

	A system-dependent type representing a semaphore.

TYPE urt_mutex: opaque
	A type representing a mutex

	A system-dependent type representing a mutex.

TYPE urt_rwlock: opaque
	A type representing a readers-writers lock

	A system dependent type representing a readers-writers lock.

FUNCTION urt_sem_new: (init_value: unsigned int, error: int * = NULL): urt_sem *
	Create a new semaphore

	This function creates and returns a new semaphore. This semaphore is unnamed and cannot be shared with other processes.

	INPUT init_value
		Initial value of the semaphore.
	INPUT error
		Optional error code return value. See explanation [here](Style#Error Reporting). One of the following values:

		- `[#URT_NO_MEM](constants)` if out of memory,
		- `[#URT_BAD_VALUE](constants)` if **`init_value`** is invalid,
		- `[#URT_FAIL](constants)` otherwise.
	OUTPUT
		A new semaphore, or `NULL` if not possible.

FUNCTION urt_sem_delete: (sem: urt_sem *): void
	Free a semaphore created by `urt_sem_new`

	This function frees a semaphore created by `[#urt_sem_new]`. If **`sem`** is `NULL`, the function silently returns.

	INPUT sem
		The semaphore to be freed.

FUNCTION urt_shsem_new: (name: const char *, init_value: unsigned int, error: int * = NULL): urt_sem *
	Create a new shared semaphore

	This function creates and returns a new shared semaphore. This semaphore will be shared
	with other processes under the given **`name`**. See further details [here](Style#Shared Resource Allocation).

	INPUT name
		The name under which the semaphore is shared.
	INPUT init_value
		Initial value of the semaphore.
	INPUT error
		Optional error code return value. See explanation [here](Style#Error Reporting). One of the following values:

		- `[#URT_NO_MEM](constants)` if out of memory,
		- `[#URT_EXISTS](constants)` if an object with that name already exists,
		- `[#URT_BAD_NAME](constants)` if given an invalid name,
		- `[#URT_BAD_VALUE](constants)` if **`init_value`** is invalid,
		- `[#URT_MAX_REACHED](constants)` if maximum number of shared objects reached,
		- `[#URT_FAIL](constants)` otherwise.
	OUTPUT
		A new semaphore, or `NULL` if not possible.

FUNCTION urt_shsem_delete: (sem: urt_sem *): void
	Free a detach from shared semaphore

	This function detaches from shared semaphore, attached to by `[#urt_shsem_attach]`, or created by `[#urt_shsem_new]`.
	If **`sem`** is `NULL`, the function silently returns. If the number of processes attached to the shared semaphore become
	zero as a result of a call to this function, the semaphore will be freed.

	See further details [here](Style#Shared Resource Allocation).

	INPUT sem
		The semaphore to be detached from or freed.

FUNCTION urt_shsem_attach: (name: const char *, error: int * = NULL): void *
	Attach to shared semaphore

	This function attaches to the shared semaphore created under **`name`**. If no semaphore with that name exists, the function
	will fail.

	INPUT name
		The name under which the semaphore is shared.
	INPUT error
		Optional error code return value. See explanation [here](Style#Error Reporting). One of the following values:

		- `[#URT_NO_MEM](constants)` if out of memory,
		- `[#URT_BAD_NAME](constants)` if given an invalid name,
		- `[#URT_NO_OBJ](constants)` if no shared object with given name exists,
		- `[#URT_FAIL](constants)` otherwise.
	OUTPUT
		A pointer to the shared semaphore, or `NULL` if failed.

FUNCTION urt_shsem_detach: (sem: urt_sem *): void
	Free or detach from shared semaphore

	The same as `[#urt_shsem_delete]`.

	INPUT sem
		See `[#urt_shsem_delete]`.

FUNCTION urt_sem_wait: (sem: urt_sem *, stop: bool * = NULL): int
NOTICE RT
	Wait on a semaphore

	This function waits on semaphore **`sem`**. If the semaphore is not available, it will stay blocked until either it is [posted](#urt_sem_post),
	there is an error, or the optional argument **`stop`** becomes `true`.

	INPUT sem
		The semaphore to wait on.
	INPUT stop
		Optional argument that can cancel the operation. See explanation [here](Style#Blocking Locks).
	OUTPUT
		Reurns one of the following:

		- `[#URT_SUCCESS](constants)` on success,
		- `[#URT_NOT_LOCKED](constants)` if **`stop`** is provided and it becomes `true` before the lock is aquired,
		- `[#URT_FAIL](constants)` otherwise.

FUNCTION urt_sem_timed_wait: (sem: urt_sem *, wait_time: urt_time): int
NOTICE RT
	Wait on a semaphore for a maximum of given time

	This function waits on semaphore **`sem`**. If the semaphore is not available until **`wait_time`** nanoseconds has passed, the function
	will return.

	INPUT sem
		The semaphore to wait on.
	INPUT wait_time
		Maximum waiting time on the semaphore.
	OUTPUT
		Reurns one of the following:

		- `[#URT_SUCCESS](constants)` on success,
		- `[#URT_NOT_LOCKED](constants)` if **`wait_time`** nanoseconds has passed and the semaphore was not available,
		- `[#URT_FAIL](constants)` otherwise.

FUNCTION urt_sem_try_wait: (sem: urt_sem *): int
NOTICE RT
	Try waiting on a semaphore

	This function tries to wait on semaphore **`sem`**. If the semaphore is not available it will immediately return.

	INPUT sem
		The semaphore to wait on.
	OUTPUT
		Reurns one of the following:

		- `[#URT_SUCCESS](constants)` on success,
		- `[#URT_NOT_LOCKED](constants)` if lock was not available,
		- `[#URT_FAIL](constants)` otherwise.

FUNCTION urt_sem_post: (sem: urt_sem *): void
NOTICE RT
	Post a semaphore

	This function posts semaphore **`sem`**. If there are threads waiting on the semaphore, one of them arbitrarily is chosen and unblocked.

	INPUT sem
		The semaphore to post.

FUNCTION urt_mutex_new: (error: int * = NULL): urt_mutex *
	Create a new mutex

	This function creates and returns a new mutex. This mutex is unnamed and cannot be shared with other processes.

	INPUT error
		Optional error code return value. See explanation [here](Style#Error Reporting). One of the following values:

		- `[#URT_NO_MEM](constants)` if out of memory,
		- `[#URT_FAIL](constants)` otherwise.
	OUTPUT
		A new mutex, or `NULL` if not possible.

FUNCTION urt_mutex_delete: (mutex: urt_mutex *): void
	Free a mutex created by `urt_mutex_new`

	This function frees a mutex created by `[#urt_mutex_new]`. If **`mutex`** is `NULL`, the function silently returns.

	INPUT mutex
		The mutex to be freed.

FUNCTION urt_shmutex_new: (name: const char *, error: int * = NULL): urt_mutex *
	Create a new shared mutex

	This function creates and returns a new shared mutex. This mutex will be shared
	with other processes under the given **`name`**. See further details [here](Style#Shared Resource Allocation).

	INPUT name
		The name under which the mutex is shared.
	INPUT error
		Optional error code return value. See explanation [here](Style#Error Reporting). One of the following values:

		- `[#URT_NO_MEM](constants)` if out of memory,
		- `[#URT_EXISTS](constants)` if an object with that name already exists,
		- `[#URT_BAD_NAME](constants)` if given an invalid name,
		- `[#URT_MAX_REACHED](constants)` if maximum number of shared objects reached,
		- `[#URT_FAIL](constants)` otherwise.
	OUTPUT
		A new mutex, or `NULL` if not possible.

FUNCTION urt_shmutex_delete: (mutex: urt_mutex *): void
	Free or detach from shared mutex

	This function detaches from shared mutex, attached to by `[#urt_shmutex_attach]`, or created by `[#urt_shmutex_new]`.
	If **`mutex`** is `NULL`, the function silently returns. If the number of processes attached to the shared mutex become
	zero as a result of a call to this function, the mutex will be freed.

	See further details [here](Style#Shared Resource Allocation).

	INPUT mutex
		The mutex to be detached from or freed.

FUNCTION urt_shmutex_attach: (name: const char *, error: int * = NULL): void *
	Attach to shared mutex

	This function attaches to the shared mutex created under **`name`**. If no mutex with that name exists, the function
	will fail.

	INPUT name
		The name under which the mutex is shared.
	INPUT error
		Optional error code return value. See explanation [here](Style#Error Reporting). One of the following values:

		- `[#URT_NO_MEM](constants)` if out of memory,
		- `[#URT_BAD_NAME](constants)` if given an invalid name,
		- `[#URT_NO_OBJ](constants)` if no shared object with given name exists,
		- `[#URT_FAIL](constants)` otherwise.
	OUTPUT
		A pointer to the shared mutex, or `NULL` if failed.

FUNCTION urt_shmutex_detach: (mutex: urt_mutex *): void
	Free or detach from shared mutex

	The same as `[#urt_shmutex_delete]`.

	INPUT mutex
		See `[#urt_shmutex_delete]`.

FUNCTION urt_mutex_lock: (mutex: urt_mutex *, stop: bool * = NULL): int
NOTICE RT
	Lock a mutex

	This function locks mutex **`mutex`**. If the mutex is not available, it will stay blocked until either it is [unlocked](#urt_mutex_unlock),
	there is an error, or the optional argument **`stop`** becomes `true`.

	INPUT mutex
		The mutex to lock.
	INPUT stop
		Optional argument that can cancel the operation. See explanation [here](Style#Blocking Locks).
	OUTPUT
		Reurns one of the following:

		- `[#URT_SUCCESS](constants)` on success,
		- `[#URT_NOT_LOCKED](constants)` if **`stop`** is provided and it becomes `true` before the lock is aquired,
		- `[#URT_FAIL](constants)` otherwise.

FUNCTION urt_mutex_timed_lock: (mutex: urt_mutex *, wait_time: urt_time): int
NOTICE RT
	Lock a mutex if possible in a maximum of given time

	This function locks mutex **`mutex`**. If the mutex is not available until **`wait_time`** nanoseconds has passed, the function
	will return.

	INPUT mutex
		The mutex to lock.
	INPUT wait_time
		Maximum waiting time on the mutex.
	OUTPUT
		Reurns one of the following:

		- `[#URT_SUCCESS](constants)` on success,
		- `[#URT_NOT_LOCKED](constants)` if **`wait_time`** nanoseconds has passed and the semaphore was not available,
		- `[#URT_FAIL](constants)` otherwise.

FUNCTION urt_mutex_try_lock: (mutex: urt_mutex *): int
NOTICE RT
	Try locking a mutex

	This function tries to lock mutex **`mutex`**. If the mutex is not available it will immediately return.

	INPUT mutex
		The mutex to lock.
	OUTPUT
		Reurns one of the following:

		- `[#URT_SUCCESS](constants)` on success,
		- `[#URT_NOT_LOCKED](constants)` if lock was not available,
		- `[#URT_FAIL](constants)` otherwise.

FUNCTION urt_mutex_unlock: (mutex: urt_mutex *): void
NOTICE RT
	Unlock a mutex

	This function unlocks mutex **`mutex`**. If there are threads waiting on the mutex, one of them arbitrarily is chosen and unblocked.

	INPUT mutex
		The mutex to unlock.

FUNCTION urt_rwlock_new: (error: int * = NULL): urt_rwlock *
	Create a new readers-writers lock

	This function creates and returns a new readers-writers lock. This lock is unnamed and cannot be shared with other processes.

	INPUT error
		Optional error code return value. See explanation [here](Style#Error Reporting). One of the following values:

		- `[#URT_NO_MEM](constants)` if out of memory,
		- `[#URT_AGAIN](constants)` if operation failed but there is a chance of success on retry,
		- `[#URT_FAIL](constants)` otherwise.
	OUTPUT
		A new readers-writers lock, or `NULL` if not possible.

FUNCTION urt_rwlock_delete: (rwlock: urt_rwlock *): void
	Free a readers-writers lock created by `urt_rwlock_new`

	This function frees a readers-writers lock created by `[#urt_rwlock_new]`. If **`rwlock`** is `NULL`, the function silently returns.

	INPUT rwlock
		The readers-writers lock to be freed.

FUNCTION urt_shrwlock_new: (name: const char *, error: int * = NULL): urt_rwlock *
	Create a new shared readers-writers lock

	This function creates and returns a new shared readers-writers lock. This lock will be shared
	with other processes under the given **`name`**. See further details [here](Style#Shared Resource Allocation).

	INPUT name
		The name under which the lock is shared.
	INPUT error
		Optional error code return value. See explanation [here](Style#Error Reporting). One of the following values:

		- `[#URT_NO_MEM](constants)` if out of memory,
		- `[#URT_EXISTS](constants)` if an object with that name already exists,
		- `[#URT_BAD_NAME](constants)` if given an invalid name,
		- `[#URT_MAX_REACHED](constants)` if maximum number of shared objects reached,
		- `[#URT_NO_SUPPORT](constants)` if the underlying system doesn't support shared readers-writers locks,
		- `[#URT_FAIL](constants)` otherwise.

	OUTPUT
		A new readers-writers lock, or `NULL` if not possible.

FUNCTION urt_shrwlock_delete: (rwlock: urt_rwlock *): void
	Free or detach from shared readers-writers lock

	This function detaches from shared readers-writers lock, attached to by `[#urt_shrwlock_attach]`, or created by `[#urt_shrwlock_new]`.
	If **`rwlock`** is `NULL`, the function silently returns. If the number of processes attached to the shared lock become
	zero as a result of a call to this function, the lock will be freed.

	See further details [here](Style#Shared Resource Allocation).

	INPUT rwlock
		The readers-writers lock to be detached from or freed.

FUNCTION urt_shrwlock_attach: (name: const char *, error: int * = NULL): void *
	Attach to shared readers-writers lock

	This function attaches to the shared readers-writers lock created under **`name`**. If no lock with that name exists, the function
	will fail.

	INPUT name
		The name under which the lock is shared.
	INPUT error
		Optional error code return value. See explanation [here](Style#Error Reporting). One of the following values:

		- `[#URT_NO_MEM](constants)` if out of memory,
		- `[#URT_BAD_NAME](constants)` if given an invalid name,
		- `[#URT_NO_OBJ](constants)` if no shared object with given name exists,
		- `[#URT_FAIL](constants)` otherwise.
	OUTPUT
		A pointer to the shared readers-writers lock, or `NULL` if failed.

FUNCTION urt_shrwlock_detach: (rwlock: urt_rwlock *): void
	Free or detach from shared readers-writers lock

	The same as `[#urt_shrwlock_delete]`.

	INPUT rwlock
		See `[#urt_shrwlock_delete]`.

FUNCTION urt_rwlock_read_lock: (rwlock: urt_rwlock *, stop: bool * = NULL): int
NOTICE RT
	Read-lock a readers-writers lock

	This function read-locks readers-writers lock **`rwlock`**. If the lock is not available, it will stay blocked until either it is
	[unlocked](#urt_rwlock_write_unlock), there is an error, or the optional argument **`stop`** becomes `true`.

	So long as the lock is not [write-locked](#urt_rwlock_write_lock) any number of readers can simultaneously acquire the lock. This number may be capped
	by system specific limitations.

	INPUT rwlock
		The readers-writers lock to lock.
	INPUT stop
		Optional argument that can cancel the operation. See explanation [here](Style#Blocking Locks).
	OUTPUT
		Reurns one of the following:

		- `[#URT_SUCCESS](constants)` on success,
		- `[#URT_NOT_LOCKED](constants)` if **`stop`** is provided and it becomes `true` before the lock is aquired,
		- `[#URT_FAIL](constants)` otherwise.

FUNCTION urt_rwlock_write_lock: (rwlock: urt_rwlock *, stop: bool * = NULL): int
NOTICE RT
	Write-lock a readers-writers lock

	This function write-locks readers-writers lock **`rwlock`**. If the lock is not available, it will stay blocked until either it is
	[unlocked](#urt_rwlock_read_unlock), there is an error, or the optional argument **`stop`** becomes `true`.

	There can be only one writer having the lock. Furthermore, a writer would stay blocked until all readers have released the lock. In a race condition,
	it is a system-specific behavior whether writers are prioritized or readers.

	INPUT rwlock
		The readers-writers lock to lock.
	INPUT stop
		Optional argument that can cancel the operation. See explanation [here](Style#Blocking Locks).
	OUTPUT
		Reurns one of the following:

		- `[#URT_SUCCESS](constants)` on success,
		- `[#URT_NOT_LOCKED](constants)` if **`stop`** is provided and it becomes `true` before the lock is aquired,
		- `[#URT_FAIL](constants)` otherwise.

FUNCTION urt_rwlock_timed_read_lock: (rwlock: urt_rwlock *, wait_time: urt_time): int
NOTICE RT
	Read-lock a readers-writers lock if possible in a maximum of given time

	This function read-locks readers-writers lock **`rwlock`**. If the lock is not available until **`wait_time`** nanoseconds has passed, the function
	will return.

	INPUT rwlock
		The readers-writers lock to lock.
	INPUT wait_time
		Maximum waiting time on the lock.
	OUTPUT
		Reurns one of the following:

		- `[#URT_SUCCESS](constants)` on success,
		- `[#URT_NOT_LOCKED](constants)` if **`wait_time`** nanoseconds has passed and the semaphore was not available,
		- `[#URT_FAIL](constants)` otherwise.

FUNCTION urt_rwlock_timed_write_lock: (rwlock: urt_rwlock *, wait_time: urt_time): int
NOTICE RT
	Write-lock a readers-writers lock if possible in a maximum of given time

	This function write-locks readers-writers lock **`rwlock`**. If the lock is not available until **`wait_time`** nanoseconds has passed, the function
	will return.

	INPUT rwlock
		The readers-writers lock to lock.
	INPUT wait_time
		Maximum waiting time on the lock.
	OUTPUT
		Reurns one of the following:

		- `[#URT_SUCCESS](constants)` on success,
		- `[#URT_NOT_LOCKED](constants)` if **`wait_time`** nanoseconds has passed and the semaphore was not available,
		- `[#URT_FAIL](constants)` otherwise.

FUNCTION urt_rwlock_try_read_lock: (rwlock: urt_rwlock *): int
NOTICE RT
	Try read-locking a readers-writers lock

	This function tries to read-lock readers-writers lock **`rwlock`**. If the lock is not available it will immediately return.

	INPUT rwlock
		The readers-writers lock to lock.
	OUTPUT
		Reurns one of the following:

		- `[#URT_SUCCESS](constants)` on success,
		- `[#URT_NOT_LOCKED](constants)` if lock was not available,
		- `[#URT_FAIL](constants)` otherwise.

FUNCTION urt_rwlock_try_write_lock: (rwlock: urt_rwlock *): int
NOTICE RT
	Try write-locking a readers-writers lock

	This function tries to write-lock readers-writers lock **`rwlock`**. If the lock is not available it will immediately return.

	INPUT rwlock
		The readers-writers lock to lock.
	OUTPUT
		Reurns one of the following:

		- `[#URT_SUCCESS](constants)` on success,
		- `[#URT_NOT_LOCKED](constants)` if lock was not available,
		- `[#URT_FAIL](constants)` otherwise.

FUNCTION urt_rwlock_read_unlock: (rwlock: urt_rwlock *): void
NOTICE RT
	Read-unlock a readers-writers lock

	This function read-unlocks readers-writers lock **`rwlock`**. If there are threads waiting on the lock, one of them arbitrarily is chosen and unblocked.

	INPUT rwlock
		The readers-writers lock to unlock.

FUNCTION urt_rwlock_write_unlock: (rwlock: urt_rwlock *): void
NOTICE RT
	Write-unlock a readers-writers lock

	This function write-unlocks readers-writers lock **`rwlock`**. If there are threads waiting on the lock, one of them arbitrarily is chosen and unblocked.

	INPUT rwlock
		The readers-writers lock to unlock.
