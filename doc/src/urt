functions urt
# URT - Unified Real-Time Interface
version version 0.1.0
author Shahbaz Youssefi
keyword real-time
keyword middleware
keyword interface
shortcut index
shortcut globals
shortcut constants
previous index
next functions urt_time

These functions setup URT itself.

FUNCTION urt_init: (): int
	Initialize URT

	This function initializes URT. It must be called before any other function can be called (except `[#urt_recover]`).

	OUTPUT
		Returns one of the following:

		- `[#URT_SUCCESS](constants)` if successful,
		- `[#URT_ALREADY](constants)` if URT is already initialized,
		- `[#URT_NO_MEM](constants)` if out of memory,
		- `[#URT_FAIL](constants)` otherwise.

FUNCTION urt_exit: (): void
	Free URT

	This function frees resources allocated by URT. It must be called before program exit.

FUNCTION urt_recover: (): void
	Recover from bad state due to crash

	If a program crashes, it may leave some internal shared entities, such as locks in a bad state. This function
	will try to recover from such cases. The function may not be able to completely recover the system if the
	damage is too severe, though.

	It is important for this function to be called when no users of URT are present. Otherwise, it is impossible to
	understand whether the current state of the system is due to a normal usage of URT by another user or a previous
	crash. Therefore, calling this function while another user is present may likely corrupt the system.

	Note: `urt_init` should **not** need to be called before this function.

	This function is a helper function for the `urt_recover` tool and most likely unnecessary to your application.

MACRO URT_GLUE: (init, body, exit, data_type, interrupted, done)
	Glue code to connect parts of the application

	This macro connects parts of the application, namely initialization, body, finalization and interrupt handling
	to abstract from differences between kernel space and user space applications.

	The user application could therefore look like this:

	```
	#include \<urt.h\>

	`struct prog_variables`
	{
		/* program variables */
	};

	`static int prog_start(struct prog_variables *vars);`
	`static void prog_body(struct prog_variables *vars);`
	`static void prog_end(struct prog_variables *vars);`

	``URT_GLUE(prog_start, prog_body, prog_end, struct prog_variables, _interrupted, _done)``

	static int prog_start(struct prog_variables *vars)
	{
		/* other initialization */
		`urt_init();`
		return 0;
	}

	static void prog_body(struct prog_variables *vars)
	{
		/* allocate some resources */
		if (_interrupted)
			goto exit_interrupted;

		/* some calculations */

		/* wait for something to happen */
		while (!_interrupted \&\& get_command() != SOME_COMMAND)
			urt_sleep(SOME_TIME);
		`if (_interrupted)`
			goto exit_interrupted;

		/* other similar situations */

		goto exit_done;
	exit_interrupted:
		urt_log("body interrupted\\n");
	exit_done:
		``_done = 1;``
	}

	static void prog_end(struct prog_variables *vars)
	{
		/* cleanup */
		`urt_exit();`
	}
	```

	INPUT init
		A small function to be called on program start.  In kernel space, this is
		the `__init` function.

		The type of this function is `int (*)(data_type *)`.
	INPUT body
		A non-real-time thread (which is the main thread in user space) that handles
		allocation of resources and various other operations.  The purpose of this function
		is to allow the init function to finish, which in kernel space signals the end of `insmod`.
		This way, `rmmod` can be called asynchronous to the execution of **`body`**.
		After the execution of **`body`**, the program waits for interrupt (user space) or
		`rmmod` (kernel space) before calling the **`exit`** function.

		The type of this function is `void (*)(data_type *)`.
	INPUT exit
		A function to be called on program exit.  In kernel space, this is
		the `__exit` funcion.

		The type of this function is `void (*)(data_type *)`.
	INPUT data_type
		Type of a variable instantiated whose address is passed to the **`init`**, **`body`** and **`exit`**
		functions.  This variable is uninitialized and must be initialized on **`init`** if intended to be
		used.  It cannot be `void`.
	INPUT interrupted
		The name of a variable (defined by this macro) that would become non-zero
		when the program is interrupted (user space) or `rmmod`ed (kernel space).
	INPUT done
		The name of a variable (defined by this macro) that should be set by the user
		(in **`body`** for example) which indicates that it is safe to call the **`exit`** function.

MACRO URT_GLUE_NO_INTERRUPT: (init, body, exit, data_type)
	Similar to `URT_GLUE` without interrupt handling

	This macro is similar to `[#URT_GLUE]` except that it does not install an interrupt handler.  It would thus be
	the responsibility of the programmer herself to ensure that **`exit`** waits for **`body`** to finish.

	INPUT init
		See `[#URT_GLUE]`.
	INPUT body
		See `[#URT_GLUE]`.
	INPUT exit
		See `[#URT_GLUE]`.
	INPUT data_type
		See `[#URT_GLUE]`.

MACRO URT_MODULE_AUTHOR: (author)
	Declare author of the application

	This macro declares the author of the application.  This macro is similar to `MODULE_AUTHOR` in the Linux kernel.

	INPUT author
		The author of the application as a C string.

MACRO URT_MODULE_LICENSE: (license)
	Declare license of the application

	This macro declares the license of the application.  This macro is similar to `MODULE_LICENSE` in the Linux kernel.

	INPUT license
		The license of the application as a C string.

MACRO URT_MODULE_DESCRIPTION: (description)
	Declare description of the application

	This macro describes the application itself.  This macro is similar to `MODULE_DESCRIPTION` in the Linux kernel.

	INPUT description
		The description of the application as a C string.
